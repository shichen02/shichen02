[{"title":"SSH 的前世今生","path":"/shichen02/2023/05/09/SSH/","content":"SSH 是一个用来解决通信安全的一个协议，1995 年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置。 SSH仅仅是一协议标准，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH。现在操作系统基本都预装了 OpenSSH OpenSSH 概述SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd。另外，OpenSSH 还提供一些辅助工具软件（比如 ssh-keygen 、ssh-agent）和专门的客户端工具（比如 scp 和 sftp）scp 是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件（即复制文件）sftp 是 SSH 提供的一个客户端应用程序，主要用来安全地访问 FTP。因为 FTP 是不加密协议，很不安全，sftp 就相当于将 FTP 放入了 SSH。 原理 实现安全通信首先想到的实现方案肯定是对数据进行加密。加密的方式主要有两种： 对称加密（也称为秘钥加密） 非对称加密（也称公钥加密） 对称加密对称加密指加密解密使用同一套秘钥。常用的对称加密算法有 AES、Blowfish、3DES、CAST128、以及Arcfour。原理图如下： 非对称加密1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。数据的加密和解密过程是通过密码体制和密钥来控制的。密码体制的安全性依赖于密钥的安全性，现代密码学不追求加密算法的保密性，而是追求加密算法的完备，即：使攻击者在不知道密钥的情况下，没有办法从算法找到突破口。根据加解密算法所使用的密钥是否相同，或能否由加(解)密密钥简单地求得解(加)密密钥。密码体制可分为对称密码体制和非对称密码体制。非对称密码体制也叫公钥加密技术，该技术是针对私钥密码体制(对称加密算法)的缺陷被提出来的。与对称密码体制不同，公钥加密系统中，加密和解密是相对独立的，加密和解密会使用两把不同的密钥，加密密钥(公开密钥)向公众公开，谁都可以使用，解密密钥(秘密密钥)只有解密人自己知道，非法使用者根据公开的加密密钥无法推算出解密密钥，这样就大大加强了信息保护的力度。公钥密码体制不仅解决了密钥分配的问题，它还为签名和认证提供了手段。非对称密码算法有很多，其中比较典型的是RSA算法，它的数学原理是大素数的分解 非对称加密如何被应用呢？以用户 TopGun 要尝试登录服务器为例，流程图如下 登录流程： 远程Server收到Client端用户TopGun的登录请求，Server把自己的公钥发给用户。 Client使用这个公钥，将密码进行加密。 Client将加密的密码发送给Server端。 远程Server用自己的私钥，解密登录密码，然后验证其合法性。 若验证结果，给Client相应的响应。 补充：这一种登陆方式是通过口令的方式登陆。需要每次输入一次密码，密码输入后通过服务端的公钥加密后进行传输到服务端，服务端的私钥进行解密。 中间人攻击上面过程本身是安全的，但是实施的时候存在一个风险： Client端如何保证接受到的公钥就是目标Server端的？，如果一个攻击者中途拦截Client的登录请求，向其发送自己的公钥，Client端用攻击者的公钥进行数据加密。攻击者接收到加密信息后再用自己的私钥进行解密，不就窃取了Client的登录信息了吗？ 如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。可以设想具体场景，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”(Man-in-the-middle attack)。 SSH解决中间人攻击1、口令登录（基于口令的认证）从上面的描述可以看出，问题就在于如何对Server的公钥进行认证？在https中可以通过CA来进行公证，可是SSH的publish key和private key都是自己生成的，没法公证。只能通过Client端自己对公钥进行确认。通常在第一次登录的时候，系统会出现下面提示信息： 1234$ ssh user@hostThe authenticity of host &#x27;host (12.18.429.21)&#x27; can&#x27;t be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 上面的信息说的是：无法确认主机host(12.18.429.21)的真实性，不过知道它的公钥指纹，询问你是否继续连接？所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d ，再进行比较，就容易多了。 很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对，或者自己甄别host地址是否正确。 1234567// 1. 假定经过风险衡量以后（一般用户直接就选择yes吧），用户决定接受这个远程主机的公钥。 Are you sure you want to continue connecting (yes/no)? yes// 2. 系统会出现一句提示，表示host主机已经得到认可。 Warning: Permanently added &#x27;host,12.18.429.21&#x27; (RSA) to the list of known hosts.// 3. 然后，会要求输入密码。 Password: (enter password)// 如果密码正确，就可以登录了。 当远程主机的公钥被接受以后，它就会被保存在文件$HOME&#x2F;.ssh&#x2F;known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是&#x2F;etc&#x2F;ssh&#x2F;ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 2、公钥登录（基于公钥的认证）使用密码登录，每次都必须输入密码，非常麻烦。好在SSH提供了另外一种可以免去输入密码过程的登录方式：公钥登录。 所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。 以用户 TopGun 为例，流程如下：公钥认证流程： Client 端用户 TopGun 将自己的公钥存放在 Server 上，追加在文件 authorized_keys 中。 Server 收到登录请求后，服务器的公钥验证通过后, 双方会依据 Diffie-Hellman 算法生成一个共享 session key （此时双方都有 session key）会话密钥将用于加密整个会话。之后 Server 随机生成一个字符串 str，并发送给 Client。 客户端通过私钥解密随机数字后，将获取的随机数与共享会话密钥结合，计算该值的 MD5 哈希值。发送给服务器 服务器使用 session key 它发送给客户端的随机 str 来自行计算 MD5 值。它将自己的计算与客户端发回的计算进行比较。如果这两个值匹配，则证明客户端拥有私钥并且客户端已通过身份验证 在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitLab上SSH keys设置视图： 这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： 1ssh-keygen 运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。运行结束以后，在$HOME&#x2F;.ssh&#x2F;目录下，会新生成两个文件：id_rsa.pub 和 id_rsa 。前者是你的公钥，后者是你的私钥。比如，我需要用用户user登录host服务器，只需再输入下面的命令，将公钥传送到远程主机host上面： 1ssh-copy-id user@host 好了，从此你再登录，就不需要输入密码了如果还是不行，就打开远程主机的&#x2F;etc&#x2F;ssh&#x2F;sshd_config这个文件，检查下面几行前面”#”注释是否取掉。 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 然后，重启远程主机的ssh服务。 1234// ubuntu系统service ssh restart// debian系统/etc/init.d/ssh restart 什么是authorized_keys文件？远程主机将用户的公钥，保存在登录后的用户主目录的$HOME&#x2F;.ssh&#x2F;authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程： 1$ ssh user@host &#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27; &lt; ~/.ssh/id_rsa.pub 这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh&#x2F;authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh&#x2F;authorized_keys’ &lt; &#x2F;.ssh&#x2F;id_rsa.pub的作用是，将本地的公钥文件&#x2F;.ssh&#x2F;id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。写入authorized_keys文件后，公钥登录的设置就完成了。我本地的ahtorized_keys文件。添加后内容如下： 12ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDQsqm2aqI3MCUcDlcqnU9JfE30TYfUjayKGf/+WvLOpFVUqhwnrAFVT7VaCW5G5Lh3IlWzGCflhl0Yjasb3BTELV+W+zHpefgEwJaNB725yfzdPvk/aGrHv7UusggMqqR11JDW2zlISo/xUysEzJ4pTnjz6AcdKUCE8biB3s37yTSa8k78g2j06tzLglr+np179jCiq9RJfKCs/omeCHbU+pyhcCk6DoL/SRHzNczfHIcJBvhWvY7CPKHb2vqD9k5d9cS2renGvB2/fCkyyNdnVZgKc3r5ufJUD+yWJ6yMHNT/hMn0uybEHuVz8s/zXjdH3xgx40UrfLs8eNKTKpAN app@bjxg-ap-27-7ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCk7sNBV8ag8KKApN4mapTQTkDEbcA3VNFIhSuO+YLTbkO29KU6FSQhlT2It2hmmmdaVJXEMx6JmQS7+62DNHIpHnzaKimEU+tKosAdOwHoZPcskMw6QlvjkhicKg7+kNsFdeSuAtE3V4ShbFPUfRNAs/9a/b56/FqqGIk6oPVu19CSvMyLnnqTht9rMQdIw4uOynogEKivgdwsAFh4qayJSz8VwklN9dx+8dqw8e9e/CxXEDWuZ2T/DtEa+gIRy0bvJaDcgzcpvxMkf+71HTpYlvkziF1YPmPX60gcyCkRkLnmM1fSkHXhAmBxZuSLc3l1VKXXWkH9rsgvxLzKuML/ app@bjxg-ap-28-7 配置 Windows Terminal1.下载 Windows Terminal在微软商店（Microsoft Store）搜索下载Windows Terminal。 2. 安装 OpenSSH 客户端在设置–&gt;应用–&gt;可选功能中添加OpenSSH客户端 3. 测试 ssh 和 scp 命令功能 4. 生成密钥在 CMD 中执行命令 ssh-keygen 5. 使用 scp 命令将 Windows 公钥发送至服务器1scp -P 22 C:\\Users\\tangsc\\.ssh\\id_rsa.pub root@1.117.62.185:~/.ssh/authorized_keys 6. 在 Windows Terminal 设置登录配置文件复制一份命令提示符的配置文件，修改命令行。 更新时间 2022年12月4日16点02分 参考文档 使用Windows Terminal免密登录Linux服务器 – 运维之路 SSH Secure Shell home page, maintained by SSH protocol inventor Tatu Ylonen. SSH clients, servers, tutorials, how-tos. SSH 基本知识 ssh原理以及与https的区别_PeipeiQ的博客-CSDN博客_ssh和https 非对称加密_百度百科 图解SSH原理","categories":["运维"]},{"title":"Hello World","path":"/shichen02/2023/05/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":["设计开发","iOS开发"]},{"title":"操作系统的发展概述与展望","path":"/shichen02/2023/05/09/操作系统的发展概述与展望/","content":"操作系统的发展概述与展望操作系统概念什么是操作系统？维基百科说操作是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序。我认为简单的说，操作系统是就是封装了底层的硬件让人们更加便捷的使用的软件。 历史发展​\t随着人工智能技术的发展，我认为以后的操作系统可能会颠覆现有的交互形式。最早的人机交互，是通过先要输入类似于自然语言的助记符的方式来告诉机器你想要的指令，为此我们需要学习很多的指令。就比如操作Linux系统，需要学习一些ls,cat,cd这样的指令。类似编程语言中的汇编语言，有一些简单的指令，然后会有一些简单的缩写加上助记符帮助人们记忆。然而这样的交互方式是绝对反人类的，人类天生对符号的记忆和感知是孱弱的。这种交互形式势必相较于图形界面来说势必拥有更高的学习负担。​\t随着算力的进一步发展，图形界面的操作系统慢慢成为了主流，使用计算机变的更加便捷。图形界面颠覆了原有的交互形式，让操作计算机这件事情变的更加简单便捷。人们通过点击，拖，拉，拽等更加自然的方式来操作机器。大量的程序员为这样的操作封装了底层的实现，平添了很多功能，比如现在的手机 APP ，就是程序员封装了底层的实现逻辑，开放给用户以简单的拖拉拽形式，让用户更加傻瓜式的借助计算机达成他们想要的操作。​\t目前为止的主流计算机，他只能执行自己机器语言。（目前来说是基于二进制的0和1为主流，不排除未来算力的发展出现了瓶颈，会出现其他形式的计算机）。程序员，就是在这个过程中扮演的是一个将人类的语言通过各种方式（如高级编程语言通过编译器编译为机器语言）翻译成机器能够听懂的执行的翻译官角色。 新的机遇​\t然而，随着现在大语言模型的发展，NLP 自然语言处理这个问题可能已经被解决了。这样的模型的出现很有可能是有一次人机对话的革命，比如说现在的说小爱同学，天猫精灵，这一些智能音响。就可以通过对话的方式来操作智能家居设备。未来我们与机器的沟通方式，就可以通过对话这种更加自然的方式来达成。通过对话就可以来达成我们想要的目的，解决实际问题。比如，说我现在想画一个画一个图纸。之前的方式就是我会用鼠标，或者是绘画板，通过点击，移动，触摸的方式，画出从A点到B点100米长的一个直线。未来我们画图就可能完全改变了，比如上面的例子，我可以直接给计算机说：“从A点到B点画一个100米的直线,然后过线AB垂直画一条50米的直线”。甚至与我根本不用一个个描述细节，直接对计算机说“给我画一个两层小别墅的设计图纸”。通过自然语言的方式去和计算交流的交互方式，又进一步降低了门槛，之前需要 1.0 需要认识符号，认识字母，2.0 需要认识复杂的图像和文字，3.0 时代可能只要你会说话就可以了。工具是应该方便人的，解放人类的创造力的，而不是人被工具所奴役。目前基于统计的大语言模型，他也不是完全没有弱点，我认为他具备了以下的缺陷， 他无法做到100%的精确，虽然人类的软件也无法做到100%的精确，但是他是有据可循的，如果发现错误，我们可以通过 debug 方式去找出问题所在去解决它。而大语言模型，如果识别错误，这可能是非常难以修改的，可能需要一次重新训练，或者更大更好的数据或者是一些新的算法。总得来说它就像一个小“黑盒”一样。所以我认为大语言模型在未来消费级的应用市场是会得到很快的普及和应用，而在一些对精度有要求或者对信息的准确度有要求的场景，他目前来说只是锦上添花，做一些辅助操作。 目前他需要强大的算力，这将会阻碍他更进一步的普及。然而随着廉价的算力的进一步发展现在只能运行到大型分布式服务器上的大语言模型，这十年甚至于五年之内有可能就能够简单的部署在一个家用电脑里。那么到时候让一个基于大语言模型的新一代操作系统很可能会迎来井喷式的发展，所以说，未来程序员的身份，会解决其中大语言模型翻译的错误，异常的处理以及效率的提升。目前为止我觉得应该在未来2到3年内，随着算力的进一步降低，这种样的系统就会开始大量的井喷，又会有一些苗头不断的出现，相关注册公司未来的4到5年吧，我觉得会引来井喷式的发展，会带来前所未有的机遇。 总结​\t总的来说，接下来的十年的软件方向，我觉得更有可能围绕大语言模型的释放出来的能力，对他进在他基础上做一些二次的开发。大家都说新的人工智能只是“分蛋糕”并没有“做大蛋糕”。而我认为，这种意义的开发，将会颠覆以往，更进一步解放人类的生产力，更大的富足人类的精神和物质生活，让我们拭目以待。","categories":["操作系统"]}]